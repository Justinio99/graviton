<?php
/**
 * generate url from raw db data
 *
 * Here we get the raw structure that has been hydrated for $ref link cases
 * by doctrine and replace it with a route generated by the symfony router.
 * We do this in it's own listener due to the fact that there is no way that
 * we can inject anything useable into the default odm hydrator and it looks
 * rather futile to hack it so we can use our own custom hydration code.
 */

namespace Graviton\DocumentBundle\Listener;

use Doctrine\ODM\MongoDB\Query\Builder;
use Doctrine\ODM\MongoDB\Query\Expr;
use Graviton\DocumentBundle\Service\ExtReferenceConverterInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\RequestStack;
use Graviton\Rql\Event\VisitNodeEvent;
use Xiag\Rql\Parser\Node\Query\AbstractArrayOperatorNode;
use Xiag\Rql\Parser\Node\Query\AbstractScalarOperatorNode;

/**
 * @author   List of contributors <https://github.com/libgraviton/graviton/graphs/contributors>
 * @license  http://opensource.org/licenses/gpl-license.php GNU Public License
 * @link     http://swisscom.ch
 */
class ExtReferenceSearchListener
{
    /**
     * @var ExtReferenceConverterInterface
     */
    private $converter;

    /**
     * @var array
     */
    private $fields;

    /**
     * @var Request
     */
    private $request;

    /**
     * construct
     *
     * @param ExtReferenceConverterInterface $converter Extref converter
     * @param array                          $fields    map of fields to process
     * @param RequestStack                   $requests  request
     */
    public function __construct(ExtReferenceConverterInterface $converter, array $fields, RequestStack $requests)
    {
        $this->converter = $converter;
        $this->fields = $fields;
        $this->request = $requests->getCurrentRequest();
    }

    /**
     * @param VisitNodeEvent $event node event to visit
     *
     * @return VisitNodeEvent
     */
    public function onVisitNode(VisitNodeEvent $event)
    {
        $node = $event->getNode();
        $builder = $event->getBuilder();

        if ($node instanceof AbstractScalarOperatorNode) {
            $fieldName = $this->getDocumentFieldName($node->getField());
            if ($fieldName !== false) {
                $this->processScalarNode($fieldName, $node, $builder);
                $event->setNode(null);
                $event->setBuilder($builder);
            }
        } elseif ($node instanceof AbstractArrayOperatorNode) {
            $fieldName = $this->getDocumentFieldName($node->getField());
            if ($fieldName !== false) {
                $this->processArrayNode($fieldName, $node, $builder);
                $event->setNode(null);
                $event->setBuilder($builder);
            }
        }

        return $event;
    }

    /**
     * Process scalar condition
     *
     * @param string                     $fieldName Document field name
     * @param AbstractScalarOperatorNode $node      Query node
     * @param Builder                    $builder   Query builder
     * @return void
     */
    private function processScalarNode($fieldName, AbstractScalarOperatorNode $node, Builder $builder)
    {
        $operatorMap = [
            'eq' => 'equals',
            'ne' => 'notEqual',
            'lt' => 'lt',
            'gt' => 'gt',
            'le' => 'lte',
            'ge' => 'gte',
        ];
        if (!isset($operatorMap[$node->getNodeName()])) {
            throw new \InvalidArgumentException(
                sprintf('Could not apply operator "%s" to extref', $node->getNodeName())
            );
        }

        $builder->addAnd(
            $this->getCompareExpression(
                $builder,
                $this->getDbRefValue($node->getValue()),
                $fieldName,
                $operatorMap[$node->getNodeName()]
            )
        );
    }

    /**
     * Process array condition
     *
     * @param string                    $fieldName Document field
     * @param AbstractArrayOperatorNode $node      Query node
     * @param Builder                   $builder   Query builder
     * @return void
     */
    private function processArrayNode($fieldName, AbstractArrayOperatorNode $node, Builder $builder)
    {
        if ($node->getValues() === []) {
            return;
        }

        $operatorMap = [
            'in'  => ['addOr', 'equals'],
            'out' => ['addAnd', 'notEqual'],
        ];
        if (!isset($operatorMap[$node->getNodeName()])) {
            throw new \InvalidArgumentException(
                sprintf('Could not apply operator "%s" to extref', $node->getNodeName())
            );
        }

        list($groupOperator, $compareOperator) = $operatorMap[$node->getNodeName()];

        $expr = $builder->expr();
        foreach ($node->getValues() as $extrefUrl) {
            $expr->$groupOperator(
                $this->getCompareExpression(
                    $builder,
                    $this->getDbRefValue($extrefUrl),
                    $fieldName,
                    $compareOperator
                )
            );
        }
        $builder->addAnd($expr);
    }

    /**
     * Get DbRef from extref URL
     *
     * @param string $url Extref URL representation
     * @return object
     */
    private function getDbRefValue($url)
    {
        try {
            return $this->converter->getDbRef($url);
        } catch (\InvalidArgumentException $e) {
            //make up some invalid refs to ensure we find nothing if an invalid url was given
            return (object) ['$ref' => false, '$id' => false];
        }
    }

    /**
     * Get document field name by query name
     *
     * @param string $searchName Exposed field name from RQL query
     * @return string|bool Field name or FALSE
     */
    private function getDocumentFieldName($searchName)
    {
        $route = $this->request->attributes->get('_route');
        if (!isset($this->fields[$route])) {
            throw new \LogicException(sprintf('Missing "%s" from extref fields map.', $route));
        }

        return array_search(
            strtr($searchName, ['..' => '.0.']),
            $this->fields[$route],
            true
        );
    }

    /**
     * Get compare expression
     *
     * @param Builder $builder         Query builder
     * @param object  $dbRef           DB reference
     * @param string  $fieldName       Field name
     * @param string  $compareOperator Compare operator
     *
     * @return Expr
     */
    private function getCompareExpression(Builder $builder, $dbRef, $fieldName, $compareOperator)
    {
        return $builder->expr()
            ->field($fieldName.'.$ref')
            ->equals($dbRef->{'$ref'})
            ->field($fieldName.'.$id')
            ->$compareOperator($dbRef->{'$id'});
    }
}
